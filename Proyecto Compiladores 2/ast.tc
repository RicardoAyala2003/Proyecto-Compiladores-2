%option lang = "C++"

%decls %{
    #include <vector>
    #include <string>
    #include <unordered_set>
    #include <unordered_map>
    #include <stdexcept>
    
    enum class BinaryOperator
    {
        PLUS, MINUS, MULT, DIV, MOD,
        LESS_THAN, GREATER_THAN, LESS_EQUAL, GREATER_EQUAL,
        EQUAL, DISTINCT,
        AND, OR
    };
    
    enum class UnaryOperator
    {
        NOT,
        NEGATE
    };
    
    std::string BinaryOpToString(BinaryOperator op);
    std::string UnaryOpToString(UnaryOperator op);
    
    class AstNode;
    using NodeVector = std::vector<AstNode*>;
    using StdString = std::string;
    using USet = std::unordered_set<std::string>;
    using VarMap = std::unordered_map<std::string, bool>;

struct Location {
    int line;
    int column;
    Location(int l = 0, int c = 0) : line(l), column(c) {}
};
%}

%{
    #include "ast.hpp"
    
    std::string BinaryOpToString(BinaryOperator op)
    {
        switch(op)
        {
            case BinaryOperator::PLUS: return "+";
            case BinaryOperator::MINUS: return "-";
            case BinaryOperator::MULT: return "*";
            case BinaryOperator::DIV: return "/";
            case BinaryOperator::MOD: return "%";
            case BinaryOperator::LESS_THAN: return "<";
            case BinaryOperator::GREATER_THAN: return ">";
            case BinaryOperator::LESS_EQUAL: return "<=";
            case BinaryOperator::GREATER_EQUAL: return ">=";
            case BinaryOperator::EQUAL: return "==";
            case BinaryOperator::DISTINCT: return "!=";
            case BinaryOperator::AND: return "&&";
            case BinaryOperator::OR: return "||";
            default: return "UNKNOWN";
        }
    }
    
    std::string UnaryOpToString(UnaryOperator op)
    {
        switch(op)
        {
            case UnaryOperator::NOT: return "!";
            case UnaryOperator::NEGATE: return "-";
            default: return "UNKNOWN";
        }
    }
    
    VarMap declaredVars;
    bool usesInputFunction = false;
    
 void checkVarDeclared(const std::string& var, int line, int column) {
    if (declaredVars.find(var) == declaredVars.end()) {
        throw std::runtime_error("Error Semántico [Línea " + std::to_string(line) + 
                               ", Columna " + std::to_string(column) + 
                               "]: Variable '" + var + "' no declarada");
    }
}

void checkVarNotRedeclared(const std::string& var, int line, int column) {
    if (declaredVars.find(var) != declaredVars.end()) {
        throw std::runtime_error("Error Semántico [Línea " + std::to_string(line) + 
                               ", Columna " + std::to_string(column) + 
                               "]: Variable '" + var + "' ya fue declarada");
    }
}
%}

%node AstNode %abstract %typedef

%node Program AstNode =
{
    AstNode *stmts;
}

%node Statement AstNode %abstract

%node StatementList Statement =
{
    NodeVector stmts;
}

%node Expression AstNode %abstract

%node VarExpression Expression =
{
    StdString var;
    int line;
    int column;
}

%node IntegerExpr Expression =
{
    int value;
}

%node FloatExpr Expression =
{
    float value;
}

%node BinaryExpr Expression =
{
    AstNode *left;
    BinaryOperator op;
    AstNode *right;
}

%node UnaryExpr Expression =
{
    UnaryOperator op;
    AstNode *operand;
}

%node InputStmt Expression =
{
}

%node AssignmentStmt Statement =
{
    AstNode *lhs;
    AstNode *rhs;
}

%node IfStmt Statement =
{
    AstNode *condition;
    AstNode *thenStmt;
    AstNode *elseStmt;
}

%node WhileStmt Statement =
{
    AstNode *condition;
    AstNode *body;
}

%node PrintStmt Statement =
{
    AstNode *expr;
}

%node BlockStmt Statement =
{
    AstNode *stmts;
}

%node VarDeclStmt Statement =
{
    AstNode *firstIdent;
    AstNode *identList;
}

%node IdentList AstNode =
{
    NodeVector idents;
}

%node IdentDecl AstNode =
{
    AstNode *identifier;
    AstNode *initExpr;
}

%node ArrayAccess Expression =
{
    AstNode *index;
}

%node ArrayDeclStmt Statement =
{
    AstNode *identifier;
    AstNode *arrayAccess;
}

%node ParExpr Expression =
{
    AstNode *expr;
}

%operation %virtual StdString toCpp(AstNode *this, USet &varSet)

toCpp(Program)
{
    declaredVars.clear();
    usesInputFunction = false;
    std::string output = "";
    std::string statements;

    output += "#include<iostream>\n";
    output += "#include<fstream>\n";
    

    statements += stmts->toCpp(varSet); 
    

    if (usesInputFunction) {
        output += "int input() {\n";
        output += "int x;\n";
        output += "std::cin >> x;\n";
        output += "return x;\n";
        output += "}\n";
    }

    output += "int main() {\n";

    for(const auto &var : varSet){
        output += "int " + var + ";\n";
    }

    output += statements;
    output += "return 0;\n}";
    return output;
}

toCpp(StatementList)
{
    std::string statements;
    for(auto *stmt : stmts)
    {
        statements += stmt->toCpp(varSet) + "\n";
    }
    return statements;
}

toCpp(VarExpression)
{
    checkVarDeclared(var, line, column);
    return var;
}

toCpp(IntegerExpr)
{
    return std::to_string(value);
}

toCpp(FloatExpr)
{
    return std::to_string(value);
}

toCpp(BinaryExpr)
{
    std::string leftCode = left->toCpp(varSet);
    std::string rightCode = right->toCpp(varSet);
    
    if (op == BinaryOperator::DIV || op == BinaryOperator::MOD) {
        return leftCode + " " + BinaryOpToString(op) + " " + rightCode;
    }
    
    return leftCode + " " + BinaryOpToString(op) + " " + rightCode;
}

toCpp(UnaryExpr)
{
    return UnaryOpToString(op) + operand->toCpp(varSet);
}

toCpp(InputStmt)
{
    usesInputFunction = true;
    return "input()";
}

toCpp(AssignmentStmt)
{
    VarExpression* varExpr = reinterpret_cast<VarExpression*>(lhs);
    std::string varName = varExpr->var;
    
    if (declaredVars.find(varName) == declaredVars.end()) {
        throw std::runtime_error("Error Semántico [Línea " + std::to_string(varExpr->line) + 
                               ", Columna " + std::to_string(varExpr->column) + 
                               "]: Variable '" + varName + "' usada sin declarar");
    }
    
    varSet.insert(varName);
    return varName + "=" + rhs->toCpp(varSet) + ";";
}

toCpp(IfStmt)
{
    if(elseStmt == nullptr)
        return "if (" + condition->toCpp(varSet) + ") " + thenStmt->toCpp(varSet) + " ";
    else
        return "if (" + condition->toCpp(varSet) + ") " + thenStmt->toCpp(varSet) + "else " + elseStmt->toCpp(varSet) + " ";
}

toCpp(WhileStmt)
{
    return "while (" + condition->toCpp(varSet) + ") " + body->toCpp(varSet) + " ";
}

toCpp(PrintStmt)
{
    return "cout << " + expr->toCpp(varSet) + " << endl;";
}

toCpp(BlockStmt)
{
    return "{\n" + stmts->toCpp(varSet) + "}\n";
}

toCpp(VarDeclStmt)
{
    std::string result;
    result += firstIdent->toCpp(varSet);
    if(identList != nullptr) {
        result += identList->toCpp(varSet);
    }
    return result;
}

toCpp(IdentList)
{
    std::string result;
    for(auto *ident : idents)
    {
        result += ident->toCpp(varSet);
    }
    return result;
}

toCpp(IdentDecl)
{
    VarExpression* varExpr = reinterpret_cast<VarExpression*>(identifier);
    std::string varName = varExpr->var;
    
    checkVarNotRedeclared(varName, varExpr->line, varExpr->column);
    
    declaredVars[varName] = true;
    varSet.insert(varName);
    
    std::string result;
    if(initExpr != nullptr) {
        result = varName + "=" + initExpr->toCpp(varSet) + ";";
    } 
    return result;
}

toCpp(ArrayAccess)
{
    return "[" + index->toCpp(varSet) + "]";
}

toCpp(ParExpr)
{
    return "(" + expr->toCpp(varSet) + ")";
}

toCpp(ArrayDeclStmt)
{
    VarExpression* varExpr = reinterpret_cast<VarExpression*>(identifier);
    std::string varName = varExpr->var;
    std::string arrayPart = arrayAccess->toCpp(varSet);
    
    checkVarNotRedeclared(varName, varExpr->line, varExpr->column);
    
    declaredVars[varName] = true;
    varSet.insert(varName);
    
    return "int " + varName + arrayPart + ";";
}